<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常见的几种排序算法</title>
    <url>/2020/05/09/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>一般来说，插入排序都采用 <code>in-place（原地）</code>在数组上实现。具体算法描述如下：<a id="more"></a></p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<h2 id="C代码实现-从小到大"><a href="#C代码实现-从小到大" class="headerlink" title="C代码实现(从小到大)"></a>C代码实现(从小到大)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> numSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, key;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numSize; i++)</span><br><span class="line">	 &#123;</span><br><span class="line">		key = nums[i];</span><br><span class="line">		j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> ((j &gt;= <span class="number">0</span>) &amp;&amp; (nums[j] &gt; key)) </span><br><span class="line">		&#123;</span><br><span class="line">			nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		nums[j + <span class="number">1</span>] = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><p>快速排序使用分治法策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。<br>步骤为：</p>
<ol>
<li>挑选基准值：从数列中挑出一个元素，称为“基准”.</li>
<li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，</li>
<li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。<br>递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</li>
</ol>
<h2 id="C代码实现（从小到大）"><a href="#C代码实现（从小到大）" class="headerlink" title="C代码实现（从小到大）"></a>C代码实现（从小到大）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = left, j = right<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">int</span> ptemp = nums[left];</span><br><span class="line">	<span class="keyword">if</span> (left &gt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (nums[j] &gt;= ptemp &amp;&amp; i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (nums[i] &lt;= ptemp &amp;&amp; i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = nums[j];</span><br><span class="line">			nums[j] = nums[i];</span><br><span class="line">			nums[i] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	nums[left] = nums[i];</span><br><span class="line">	nums[i] = ptemp;</span><br><span class="line">	QuickSort(nums, left, i - <span class="number">1</span>);</span><br><span class="line">	QuickSort(nums, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="算法例子"><a href="#算法例子" class="headerlink" title="算法例子"></a>算法例子</h2><p>对一组数组，例如：<br>1 3 5 7 9 2 4 6 8 0<br>首先将第一个作为最小值，然后在后面的元素中找到比第一个小的值，将两者交换。<br>其次，将第二个数作为最小值，再次在后面找到比该数小的值，两者再交换。<br>重复上述步骤，直至全部交换完成。</p>
<h2 id="C代码实现（从小到大）-1"><a href="#C代码实现（从小到大）-1" class="headerlink" title="C代码实现（从小到大）"></a>C代码实现（从小到大）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)    </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt; a[<span class="built_in">min</span>]) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">min</span> = j; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">min</span> != i)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = a[<span class="built_in">min</span>]; </span><br><span class="line">			a[<span class="built_in">min</span>] = a[i];</span><br><span class="line">			a[i] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>日记</title>
    <url>/2021/09/15/%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="78cfe5e1350ac2b0cf93687b618494c19cafb0a93e1c35b6fc0c839caaffc4e1">c7c80392cb960646731cc7845c64bcfa417de9bb357aa7ffe56a73d5d347aa1fad2be20fe648ae08473eb8f762853e5c3c86bc808526b57b6cc4fc2baad362087c1dd22dcb6e98798219b184640e46c08d1ed69e5033793c981090670101db99bf3179e914ded72383601db98301fe953cd84c634868a63c9a84d92604fb2cc10e7f45003c698724560eaec9fddc11829ca3c3285aeec69cb03041eb97212230180ac4197663e817a65b4c28326eb0dbb54c911c5b9d059dac3f544c01ce00d7623c75db2062180e1a2bc01c5972633db11015b51ee841a5224455333f8fccba0df307566ed3f14c551d88b22499038fe71d8f25a4e186fe90a07c57cac42eb3b3dba93d6c7e302a4e1774187768a5cb862bc3d224275b6df01c41d4fdd811ae3aae08e62cc562d2e92586b9230a85745a0ca72b59a81764bf88f204f37aab0404dd1e35c4867266af87330908d6fb851fa890c805fa1feda10492f13ada3c593c55a436ab6462cb18589a5531f1d35b634871f7ad7f2b1c4214fa3446012dadb3f9a053bf249c248cc3c521f57fa9da3c35dc92af71e9aab6641d9f1e0851fa9d74299895764b4b8e860ebc259b376b39224a08a7dc8f103cfe5228f35dc2176e6e0d4501c933c2b78375b27ecf0fdc63ec788911da19ec2fccd7499ebdf37fee0040bf0fb2151aeb48001093ef142a0537f5780a201656eb677de06f2999d8bf9d6cd0b3b3fd0d73677e4b200c71c0b8c754aa927896254f207411d32111cc</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
</search>
