<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>diary</title>
    <url>/2020/05/09/diary/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="您好, 这里需要密码." /><label>您好, 这里需要密码.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="a8748d6ffda0a7aa3432229efde3bcb36d0e124c3d22612c4a961c9f89491efb">353f7a100a8d860ac08f2e18db7afac18b478d7ba70d0d2ecab69a53b138d959044666268474a7ef163146329ad79060d5177af8c676b0621c6e9b9832ac666eb5f740ef93fde65fd2337229dcb51e6f1ecb44cde2261d465b4b2a518fed4ac551f1e69f8b49a7fd508aa60342d0f48c6c2b9637e2c6ee810827d77fd584bb552268ef481a8bc6996429fcd1f02bf342b8310948978e918ae3df501a0f4bc0ff0eda30261fab9d918548333ebd590f3071b50b93eab4ca2886d1ceb30b251eb9b2ad143f23343a38a31461bdaee54bd8f9da05436408787358bc23d139102eee9479e8dca0fb7fe5b8b2e70c80f3d6e9f849637abb889b417d723d827d88c0611ec75ef80799118ab403886b861525c676c9259fbec266eb1d7692591dc24e14cc1a5d05f067a93e9968083405442f1c86d47f9e6ddf9e4a1b78417019a7ccceb0667a1248715d58aacc98a7b73eb747bae2ded29b567807eca837a619fc0219c13c65a8167c649604368d3fef96381803c32a7a621572b09b4a1371e066e69ca640e121b9ec1462c8d74f4904115186ab01e99a31e7652b321c5a5592c84cf00537aeffac9f003347a12661cd826bd9774bf02958f8176beeeeaa78851111ebc4dedc4f4907b3ca584bac12b11c9abab35d8101ecd9e6839a503c2c89b86fbb2f87852a7af72a42059c75e7f6af523f9efb35f930eeab34e8090d6a6fd3396f4b12eb367160d9b05ebef04fc4f96ce44197e1d9962c12dd54c468c56e0fee782853adf7e6f5d29eb11da83e85c902d831fdc275b9687d09f711ef6bb1f87acbeda39b0ef9e95a1638819682a5094bdb6826e634e83485bec696de7b1115c65ebbd8ec5674d72708e4047f96959738d8b6d5c384fb214d85329b5de6687e82aca1e7cc9017365191616f235ee8a446ae7367e0267e55e28216ff00f513ba667acbc3814ff3f965df22f9e35d57a24368c6df06e964275214e127f9c242048ef245d963cb0fabd8d46fe5b44546e1a4c2e933e58599a6e1081cac41b776139c6c140e0a41b7fe352181c0fc1d02dc20e2d473a88f8dda74821eb299edd7d365d6</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的几种排序算法</title>
    <url>/2020/05/09/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>一般来说，插入排序都采用 <code>in-place（原地）</code>在数组上实现。具体算法描述如下：<a id="more"></a></p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<h2 id="C代码实现-从小到大"><a href="#C代码实现-从小到大" class="headerlink" title="C代码实现(从小到大)"></a>C代码实现(从小到大)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> numSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, key;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numSize; i++)</span><br><span class="line">	 &#123;</span><br><span class="line">		key = nums[i];</span><br><span class="line">		j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> ((j &gt;= <span class="number">0</span>) &amp;&amp; (nums[j] &gt; key)) </span><br><span class="line">		&#123;</span><br><span class="line">			nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		nums[j + <span class="number">1</span>] = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><p>快速排序使用分治法策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。<br>步骤为：</p>
<ol>
<li>挑选基准值：从数列中挑出一个元素，称为“基准”.</li>
<li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，</li>
<li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。<br>递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</li>
</ol>
<h2 id="C代码实现（从小到大）"><a href="#C代码实现（从小到大）" class="headerlink" title="C代码实现（从小到大）"></a>C代码实现（从小到大）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = left, j = right<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">int</span> ptemp = nums[left];</span><br><span class="line">	<span class="keyword">if</span> (left &gt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (nums[j] &gt;= ptemp &amp;&amp; i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (nums[i] &lt;= ptemp &amp;&amp; i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = nums[j];</span><br><span class="line">			nums[j] = nums[i];</span><br><span class="line">			nums[i] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	nums[left] = nums[i];</span><br><span class="line">	nums[i] = ptemp;</span><br><span class="line">	QuickSort(nums, left, i - <span class="number">1</span>);</span><br><span class="line">	QuickSort(nums, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="算法例子"><a href="#算法例子" class="headerlink" title="算法例子"></a>算法例子</h2><p>对一组数组，例如：<br>1 3 5 7 9 2 4 6 8 0<br>首先将第一个作为最小值，然后在后面的元素中找到比第一个小的值，将两者交换。<br>其次，将第二个数作为最小值，再次在后面找到比该数小的值，两者再交换。<br>重复上述步骤，直至全部交换完成。</p>
<h2 id="C代码实现（从小到大）-1"><a href="#C代码实现（从小到大）-1" class="headerlink" title="C代码实现（从小到大）"></a>C代码实现（从小到大）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)    </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt; a[<span class="built_in">min</span>]) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">min</span> = j; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">min</span> != i)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = a[<span class="built_in">min</span>]; </span><br><span class="line">			a[<span class="built_in">min</span>] = a[i];</span><br><span class="line">			a[i] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
